// THIS IS DECOMPILED PROPRIETARY CODE - USE AT YOUR OWN RISK.
//
// The original code belongs to Daisuke "Pixel" Amaya.
//
// Modifications and custom code are under the MIT licence.
// See LICENCE.txt for details.

#include "Draw.h"

#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "WindowsWrapper.h"

#include "CommonDefines.h"
#include "Debug.h"
#include "Draw.h"
#include "Main.h"
#include "Input.h"
#include "Tags.h"

#include "gba.h"
//#include <maxmod9.h>

#include "malloc.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h> 

#include "lodepng.h"



#include "Game.h"
#include "Sound.h"

#include "fopen.h"

#include "Sound.h"
#include "MiniMap.h"

#include "nifi.h"

#include "errno.h"

#include "NitroEngineBMP.h"


#include "File.h"


void Timer_1ms()
{

}

struct VramSlot
{
	SurfaceID id;
	int atlas;
	int x;
	int y; 
};

#include "gba.h"

RECT grcGame = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
RECT grcFull = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT};

EWRAM_DATA SURFACE surf[SURFACE_ID_MAX] = {0};

//PrintConsole bottomScreen;


#ifndef JAPANESE
static char* font_letters[3] = {
	" !\"#$%&`()*+,-./0123456789:;<=>?",
	"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]%_",
	"'abcdefghijklmnopqrstuvwxyz{|}~"
};
#else
static char* font_letters[] = {
" !\"#$%&`()*+,-./0123456789:;<=>?",
"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_",
"'abcdefghijklmnopqrstuvwxyz{|}~~"
};

static unsigned char font_letters_shift_jis[] =
{

0x81,0x58, 0x81,0x41, 0x81,0x75, 0x81,0x76, 0x81,0x42, 0x82,0x92, 0x82,0x51, 0x81,0x7c, 0x82,0x56, 0x82,0x52, 0x81,0x69, 0x81,0x7b, 0x82,0x53, 0x81,0x44, 0x82,0x9a, 0x82,0x55, 0x82,0x6c, 0x81,0x60, 0x81,0x48, 0x82,0x77, 0x82,0x50, 0x82,0x58, 0x82,0x63, 0x82,0x6f, 0x81,0x49, 0x81,0x6a, 0x81,0x40, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 
0x83,0x57, 0x83,0x7a, 0x83,0x6c, 0x83,0x4e, 0x83,0x72, 0x83,0x87, 0x83,0x47, 0x83,0x5e, 0x83,0x8f, 0x83,0x6b, 0x83,0x70, 0x83,0x86, 0x83,0x7e, 0x83,0x51, 0x83,0x54, 0x83,0x43, 0x83,0x49, 0x83,0x67, 0x83,0x8d, 0x83,0x48, 0x83,0x4b, 0x83,0x7b, 0x83,0x5d, 0x83,0x69, 0x83,0x5f, 0x83,0x88, 0x83,0x5b, 0x83,0x42, 0x83,0x6d, 0x83,0x50, 0x83,0x4a, 0x83,0x46, 
0x83,0x7d, 0x83,0x6a, 0x83,0x80, 0x83,0x79, 0x83,0x45, 0x83,0x40, 0x83,0x85, 0x81,0x5b, 0x83,0x7c, 0x83,0x93, 0x81,0x45, 0x83,0x4c, 0x83,0x55, 0x83,0x53, 0x83,0x77, 0x83,0x4d, 0x83,0x6f, 0x83,0x8a, 0x83,0x56, 0x83,0x76, 0x83,0x60, 0x83,0x75, 0x83,0x4f, 0x83,0x8c, 0x83,0x84, 0x83,0x71, 0x83,0x6e, 0x83,0x94, 0x83,0x82, 0x83,0x44, 0x83,0x73, 0x83,0x81, 
0x83,0x89, 0x83,0x68, 0x83,0x8b, 0x83,0x5c, 0x83,0x96, 0x83,0x5a, 0x83,0x64, 0x83,0x52, 0x83,0x58, 0x83,0x59, 0x83,0x66, 0x83,0x83, 0x83,0x74, 0x83,0x63, 0x83,0x41, 0x83,0x92, 0x83,0x65, 0x83,0x78, 0x83,0x62, 0x82,0x61, 0x82,0x66, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 
0x82,0xe6, 0x82,0xc4, 0x82,0xa9, 0x82,0xe9, 0x82,0xa6, 0x82,0xb7, 0x82,0xa0, 0x82,0xbf, 0x82,0xa4, 0x82,0xdc, 0x82,0xc5, 0x82,0xe4, 0x82,0xae, 0x82,0xa7, 0x82,0xc0, 0x82,0xe8, 0x82,0xca, 0x82,0xa8, 0x82,0xe7, 0x82,0xb3, 0x82,0xd6, 0x82,0xc7, 0x82,0xad, 0x82,0xeb, 0x82,0xe2, 0x82,0xf1, 0x82,0xdd, 0x82,0xb8, 0x82,0xdb, 0x82,0xed, 0x82,0xb1, 0x82,0xc6, 
0x82,0xc3, 0x82,0xcb, 0x82,0xc1, 0x82,0xb2, 0x82,0xa3, 0x82,0xda, 0x82,0xa2, 0x82,0xa5, 0x82,0xd3, 0x82,0xd8, 0x82,0xcc, 0x82,0xba, 0x82,0xd9, 0x82,0xcf, 0x82,0xea, 0x82,0xce, 0x82,0xe1, 0x82,0xdf, 0x82,0xa1, 0x82,0xc8, 0x82,0xaa, 0x82,0xac, 0x82,0xab, 0x82,0xb9, 0x82,0xd4, 0x82,0xc2, 0x82,0xf0, 0x82,0xb0, 0x82,0xc9, 0x82,0xd0, 0x82,0xb5, 0x82,0xbe, 
0x82,0xbc, 0x82,0x9f, 0x82,0xb4, 0x82,0xbd, 0x82,0xaf, 0x82,0xe5, 0x82,0xb6, 0x82,0xd7, 0x82,0xcd, 0x82,0xde, 0x82,0xe0, 0x82,0xbb, 0x82,0xd1, 0x8b,0x9f, 0x87,0x56, 0x87,0x54, 0x81,0x46, 0xa5,0xa5, 0x81,0xf4, 0x81,0xa1, 0x81,0xaa, 0x87,0x57, 0x81,0xab, 0x81,0x63, 0x81,0xa9, 0x87,0x55, 0x81,0xa8, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 
0x92,0x81, 0x90,0xe0, 0x8b,0x46, 0x91,0x9f, 0x88,0xea, 0x89,0xf1, 0x93,0x79, 0x96,0xc6, 0x91,0xfc, 0x91,0xcf, 0x93,0xc1, 0x91,0xd5, 0x92,0x40, 0x95,0xca, 0x8d,0x55, 0x8a,0xae, 0x8e,0xd8, 0x93,0x87, 0x90,0xed, 0x93,0x9e, 0x8a,0xee, 0x89,0xef, 0x8c,0x92, 0x8d,0x4e, 0x92,0xbe, 0x93,0xfc, 0x91,0x66, 0x90,0x67, 0x8f,0xe4, 0x8c,0x82, 0x8f,0xb0, 0x8f,0x57, 
0x89,0xf7, 0x91,0x9d, 0x95,0x69, 0x90,0xf3, 0x8b,0x9b, 0x97,0x46, 0x8f,0x80, 0x8f,0x98, 0x89,0xa3, 0x90,0xd8, 0x89,0xae, 0x8c,0x8c, 0x96,0x82, 0x8e,0x64, 0x8e,0x8e, 0x89,0xe4, 0x94,0xad, 0x8e,0x86, 0x8b,0x77, 0x8e,0xb8, 0x8f,0x68, 0x92,0x73, 0x95,0xf1, 0x88,0xc8, 0x91,0xcc, 0x8f,0x45, 0x90,0xcc, 0x94,0x87, 0x92,0x85, 0x97,0x64, 0x8e,0x6e, 0x93,0x58, 
0x92,0xb5, 0x93,0x49, 0x94,0x70, 0x90,0xa7, 0x91,0xd2, 0x89,0xc6, 0x8c,0xbe, 0x97,0x7a, 0x8b,0xf3, 0x8e,0x96, 0x8a,0xdc, 0x97,0xc7, 0x95,0xdb, 0x8b,0x5a, 0x8d,0xcf, 0x8c,0x9a, 0x97,0x6c, 0x97,0x5e, 0x92,0x99, 0x90,0xa8, 0x94,0x77, 0x8f,0x8a, 0x89,0xca, 0x93,0x96, 0x8e,0xc0, 0x89,0x73, 0x88,0xc0, 0x98,0x46, 0x96,0x88, 0x8b,0xc7, 0x92,0x59, 0x8c,0xf5, 
0x91,0xe8, 0x94,0x92, 0x8e,0x71, 0x97,0x8e, 0x91,0x53, 0x92,0x63, 0x93,0x64, 0x89,0xba, 0x89,0x69, 0x8c,0x52, 0x90,0x65, 0x96,0xd9, 0x95,0x7e, 0x8f,0x49, 0x96,0xda, 0x88,0xab, 0x97,0x8a, 0x8c,0xc9, 0x96,0xf0, 0x93,0xa6, 0x96,0xa1, 0x8b,0x71, 0x96,0x54, 0x88,0xe1, 0x94,0x9a, 0x93,0xa1, 0x8c,0xb3, 0x8b,0x4c, 0x8e,0x76, 0x9c,0x6a, 0x96,0x5f, 0x8c,0x59, 
0x8d,0x73, 0x8f,0xe6, 0x96,0x4f, 0x90,0x5e, 0x90,0xc9, 0x8b,0x74, 0x93,0x60, 0x8e,0x67, 0x8f,0x9f, 0x94,0xc4, 0x89,0xd2, 0x8d,0x91, 0x90,0x5a, 0x91,0xe5, 0x97,0x8d, 0x92,0x87, 0x9c,0x70, 0x95,0xbd, 0x98,0x53, 0x94,0x6a, 0x98,0x4c, 0x8c,0x5a, 0x8b,0xe2, 0x8b,0xc3, 0x89,0xf2, 0x8c,0xc5, 0x8a,0x44, 0x90,0x8f, 0x8b,0xad, 0x95,0xdf, 0x8b,0x80, 0x8f,0xda, 
0x8e,0x9d, 0x93,0x71, 0x92,0xb2, 0x95,0xa1, 0x90,0x69, 0x97,0x44, 0x94,0x5c, 0x95,0xd4, 0x8f,0x82, 0x97,0x74, 0x92,0x9d, 0x89,0xf9, 0x9c,0x66, 0x94,0x52, 0x93,0xb1, 0x97,0x42, 0x92,0x65, 0x91,0x9b, 0x88,0xc5, 0x91,0x49, 0x92,0xc9, 0x91,0xe0, 0x8e,0x4f, 0x88,0xf6, 0x91,0x5f, 0x8b,0x4d, 0x8c,0xe3, 0x93,0x68, 0x8f,0x91, 0x8b,0x4e, 0x90,0xee, 0x88,0xd3, 
0x8d,0xf4, 0x8f,0xac, 0x93,0x69, 0x90,0x48, 0x96,0xba, 0x8c,0xae, 0x8c,0x4a, 0x8e,0x80, 0x89,0xf6, 0x8c,0xaf, 0x8d,0xce, 0x93,0xdb, 0x8c,0xc0, 0x91,0x96, 0x93,0xfa, 0x8d,0x9e, 0x8a,0x79, 0x89,0xb6, 0x8f,0x43, 0x8f,0x6b, 0x8b,0x40, 0x8f,0x50, 0x88,0xc3, 0x8f,0xb8, 0x91,0xb6, 0x92,0xde, 0x8e,0x6d, 0x8f,0x8f, 0x98,0x72, 0x8d,0xec, 0x91,0xbd, 0x93,0x56, 
0x8e,0x47, 0x98,0x4a, 0x89,0xf0, 0x95,0xf6, 0x91,0x4f, 0x95,0x76, 0x96,0xdf, 0x97,0xac, 0x8b,0xef, 0x93,0xb4, 0x8b,0x53, 0x8f,0xc4, 0x8a,0x4b, 0x8f,0xd8, 0x88,0xa2, 0x97,0x88, 0x93,0x7a, 0x8d,0xc0, 0x8a,0xd6, 0x8a,0x4a, 0x8e,0x97, 0x95,0xa5, 0x8a,0x98, 0x94,0x7c, 0x88,0xe6, 0x8c,0x8b, 0x95,0xc2, 0x8d,0x7e, 0x94,0xe6, 0x93,0x5d, 0x92,0x9a, 0x89,0xb4, 
0x8e,0xf3, 0x90,0xda, 0x90,0xbb, 0x93,0xa5, 0x92,0x69, 0x8f,0xce, 0x93,0xb9, 0x8c,0xf8, 0xe8,0x88, 0x8d,0x6c, 0x94,0x4f, 0x8d,0xbb, 0x97,0xf4, 0x8d,0x93, 0x8e,0x9f, 0x95,0x53, 0x89,0x9e, 0x90,0xf2, 0x96,0xb3, 0x95,0xa0, 0x88,0xf3, 0x8a,0xc3, 0x96,0x5c, 0x8f,0x6f, 0x8e,0xe3, 0x90,0xab, 0x8a,0xa5, 0x95,0x83, 0x95,0x61, 0x8e,0x78, 0x8c,0x9f, 0x92,0x67, 
0x91,0xbe, 0x8b,0x96, 0x8e,0xe8, 0x8a,0x6d, 0x97,0xc6, 0x94,0xdf, 0x96,0x43, 0x95,0x7c, 0x94,0x5f, 0x9c,0xdf, 0x90,0x56, 0x8a,0x42, 0x89,0xa1, 0x92,0x55, 0x90,0x6b, 0x94,0xaa, 0x95,0xc7, 0x8e,0x55, 0x96,0xa2, 0x89,0x9c, 0x8b,0xe6, 0x8b,0x76, 0x8e,0xa9, 0x92,0xe8, 0x97,0xc3, 0x8e,0xe6, 0x8a,0x84, 0x89,0xd4, 0x97,0xe9, 0x93,0xaf, 0x95,0x40, 0x8b,0xc8, 
0x89,0x8a, 0x95,0xf0, 0x8a,0x6f, 0x8f,0x9d, 0x91,0xe6, 0x97,0xa3, 0x8b,0x8b, 0x91,0xbc, 0x8a,0xa8, 0x96,0x9c, 0x90,0x54, 0x8d,0x4b, 0x8e,0x9e, 0x97,0xbf, 0x96,0xac, 0x94,0xe0, 0x9c,0x72, 0x98,0x5e, 0x8b,0xa6, 0x8c,0x95, 0x96,0xea, 0x88,0xc9, 0x91,0x80, 0x92,0xb7, 0x8b,0xf0, 0x91,0xca, 0x8d,0xf5, 0x89,0xdf, 0x8b,0x58, 0x95,0x9c, 0x95,0xd6, 0x8e,0xcb, 
0x8c,0x57, 0x8f,0x5a, 0x93,0xaa, 0x92,0x4a, 0x95,0xf3, 0x8d,0xa1, 0x96,0xe8, 0x8a,0xed, 0x8a,0xeb, 0x8d,0x96, 0x95,0x73, 0x89,0xbb, 0x91,0xb9, 0x8e,0x59, 0x89,0x9f, 0x90,0x47, 0x8d,0xa2, 0x90,0xb0, 0x8a,0xe8, 0x92,0xfa, 0x8d,0xc4, 0x8b,0xb0, 0x90,0xcd, 0x91,0x9e, 0x91,0x75, 0x8b,0x60, 0x8c,0x41, 0x88,0xf5, 0x90,0xac, 0x88,0xd7, 0x8a,0x5b, 0x95,0x74, 
0x89,0x5e, 0x91,0x8a, 0x91,0xf2, 0x91,0x52, 0x93,0x72, 0x92,0x75, 0x96,0xca, 0x95,0xa8, 0x92,0xca, 0x96,0xd2, 0x94,0xe4, 0x95,0xfb, 0x90,0xa2, 0x97,0xfb, 0x8e,0xe1, 0x8d,0x75, 0x8e,0x70, 0x92,0x6d, 0x8c,0xa2, 0xe3,0xa9, 0x92,0xb4, 0x98,0x62, 0x96,0xaf, 0x8c,0xea, 0x90,0x81, 0x8e,0xba, 0x97,0x70, 0x8e,0xe5, 0x92,0x42, 0x8f,0x5c, 0x95,0x97, 0x8b,0xc9, 
0x95,0x90, 0x89,0xa9, 0x88,0xd0, 0x8c,0xfb, 0x97,0xcd, 0x8d,0xcb, 0x8b,0xa5, 0x8c,0x6e, 0x8a,0x88, 0x8f,0x83, 0x89,0xaf, 0x92,0xa4, 0x8e,0xbf, 0x89,0x84, 0x90,0xb3, 0x95,0xe2, 0x8d,0xc5, 0x93,0x90, 0x90,0xd4, 0x92,0xad, 0x8f,0x71, 0x88,0xe7, 0x98,0x40, 0x8a,0xfa, 0x8f,0xad, 0x8f,0x70, 0x8e,0x52, 0x91,0x83, 0x96,0xbd, 0x91,0x7a, 0x89,0xce, 0x94,0xfc, 
0x94,0xc2, 0x93,0x6e, 0x8e,0xaf, 0x89,0xc1, 0x8a,0xb4, 0x8c,0x60, 0x92,0xb8, 0x8e,0xd2, 0x8c,0xec, 0x95,0xac, 0x94,0x8e, 0x91,0xc5, 0x8c,0xb4, 0x89,0xb0, 0x8c,0xa4, 0x8e,0x84, 0x90,0xb9, 0x92,0x72, 0x89,0xbd, 0x90,0xce, 0x97,0x45, 0x8a,0x57, 0x98,0x66, 0x8f,0x62, 0x90,0xba, 0x96,0xa7, 0x94,0xb1, 0x90,0x6c, 0x8f,0xed, 0x94,0xbb, 0x96,0xe9, 0x8c,0xb5, 
0x93,0x78, 0x90,0x53, 0x89,0xc2, 0x93,0xac, 0x94,0xf5, 0x89,0xe8, 0x8b,0xea, 0x8e,0x40, 0x8e,0x63, 0x8a,0xc7, 0x8c,0x4e, 0x90,0xaf, 0x96,0xa3, 0x93,0xf1, 0x8d,0x9c, 0x8f,0xbb, 0x92,0x78, 0x91,0x95, 0x8d,0xc8, 0x97,0xe7, 0x8e,0x45, 0x91,0xde, 0x97,0xad, 0x8f,0x9c, 0x93,0x53, 0x8d,0x8f, 0x92,0x62, 0x97,0x76, 0x8b,0x7e, 0x92,0x66, 0x8e,0x7e, 0x88,0xf9, 
0x97,0xa7, 0x8c,0x8e, 0x92,0x6a, 0x95,0xcf, 0x96,0x7b, 0x8b,0xf2, 0x96,0xc0, 0x8f,0x88, 0x96,0xb2, 0x93,0xef, 0x8b,0x7b, 0x8b,0x78, 0x94,0xbc, 0x8f,0x4c, 0x95,0x5c, 0x8f,0xf3, 0x91,0x72, 0x91,0x97, 0x97,0x91, 0x8c,0x76, 0x8f,0xc7, 0x97,0xb7, 0x8c,0xe5, 0x89,0x80, 0x88,0xa4, 0x94,0xf2, 0x88,0xcd, 0x95,0xaa, 0x93,0xe4, 0x92,0x6e, 0x95,0xfa, 0x91,0x6f, 
0x8e,0xed, 0x8b,0xb6, 0x93,0xe9, 0x95,0x4b, 0x8b,0x79, 0x96,0x6c, 0x94,0xbd, 0x89,0x93, 0x8e,0xce, 0x8b,0x89, 0x89,0x5c, 0x8c,0x99, 0x94,0x7a, 0x94,0x6e, 0x95,0x59, 0x8a,0x69, 0x8d,0x87, 0x93,0xbe, 0x94,0x6b, 0x8f,0x95, 0x9f,0x42, 0x93,0x6f, 0x91,0x68, 0xe3,0x4a, 0x8d,0xb8, 0x91,0xa1, 0x95,0xe9, 0x8e,0x95, 0x8a,0x4f, 0x8a,0xef, 0x91,0x81, 0x95,0x95, 
0x8e,0x53, 0x8a,0xf6, 0x8f,0xc0, 0x91,0xe4, 0x97,0x4c, 0x95,0x91, 0x94,0xcd, 0x8f,0x87, 0x96,0x68, 0x89,0x87, 0x92,0xa3, 0x96,0xbc, 0x97,0xe2, 0x8d,0xe7, 0x8e,0x77, 0x93,0xae, 0x96,0x6b, 0x92,0x8e, 0x92,0xa7, 0x95,0xb7, 0x95,0x9e, 0x97,0xb9, 0x97,0x98, 0x96,0xc5, 0x95,0xd3, 0x8b,0x86, 0x98,0x41, 0x8d,0x98, 0x8f,0xc1, 0x8c,0xa9, 0x94,0x43, 0x93,0xcb, 
0x91,0xab, 0x91,0xf0, 0x8c,0xad, 0x8c,0xb1, 0x8d,0xdd, 0x8f,0xe3, 0x89,0x42, 0x8a,0x51, 0x96,0x5d, 0x96,0xe2, 0x93,0x7c, 0x96,0xd8, 0x8c,0x7d, 0x91,0xa4, 0x89,0x68, 0x8a,0x7c, 0x92,0x54, 0x89,0x74, 0x8f,0x89, 0x90,0x85, 0x93,0x8a, 0x95,0x89, 0x97,0x59, 0x94,0x4e, 0x92,0xc7, 0x8e,0xb9, 0x8b,0x6c, 0x89,0x70, 0x90,0xf6, 0xe9,0x78, 0x8c,0xc3, 0x98,0x61, 
0x97,0xdf, 0x8b,0xe0, 0x8c,0xc4, 0x97,0xb3, 0x8c,0x88, 0x95,0xe6, 0x8b,0x8f, 0x95,0x82, 0x90,0xc3, 0x92,0x5b, 0x8d,0x95, 0x94,0x74, 0x93,0x7b, 0x90,0xe6, 0x90,0xe2, 0x8d,0xb0, 0x89,0xe5, 0x8d,0xcd, 0x93,0xf7, 0x8d,0x48, 0x95,0xe7, 0x92,0x44, 0x91,0xa7, 0x92,0x86, 0x96,0x40, 0x8b,0xfc, 0x8e,0xe2, 0x94,0xa0, 0x90,0xb8, 0x89,0xf3, 0x98,0x43, 0x8f,0xcc, 
0x91,0xce, 0x8f,0x5d, 0x8e,0x6f, 0x96,0xad, 0x8a,0xf4, 0x8b,0xc6, 0x94,0x73, 0x93,0x9a, 0x96,0x96, 0x94,0x84, 0x91,0xba, 0x95,0xb6, 0x97,0x9d, 0x8d,0x72, 0x96,0xbe, 0x8d,0xa9, 0x8a,0xe7, 0x8b,0x8e, 0x93,0x44, 0x91,0x4d, 0x8b,0xdf, 0x94,0xb2, 0x89,0xf5, 0x8b,0xd6, 0x8a,0xe6, 0x8c,0xb9, 0x90,0x51, 0x88,0xe3, 0x8c,0xb8, 0x8e,0xd7, 0x92,0xe2, 0x8d,0xc7, 
0x8d,0xe2, 0x91,0x63, 0x8b,0xb3, 0x90,0x4d, 0x89,0xb9, 0x90,0x46, 0x92,0xd7, 0x94,0x68, 0x8c,0xfc, 0x95,0xba, 0x97,0x7e, 0x92,0x45, 0x94,0xd4, 0x91,0x9c, 0x91,0xb1, 0x8d,0x4c, 0x91,0xa6, 0x88,0xda, 0x96,0xb0, 0x8c,0xf0, 0x8d,0xb7, 0x88,0xf8, 0x8e,0xf4, 0x94,0xe9, 0x97,0x54, 0x90,0x94, 0x93,0xc7, 0x8a,0xb7, 0x95,0x94, 0x8b,0x41, 0x8d,0x82, 0x8f,0x65, 
0x95,0x43, 0x9b,0x7a, 0x8c,0xf7, 0x8f,0xea, 0x93,0xe0, 0x8b,0x92, 0x96,0xec, 0x93,0x5f, 0x92,0x83, 0x91,0xe3, 0x95,0xea, 0x8a,0xd1, 0x90,0xf5, 0x8f,0x97, 0x90,0x66, 0x97,0x5c, 0x91,0x88, 0x97,0x48, 0x8b,0x43, 0x94,0x4d, 0x89,0xe6, 0x91,0x71, 0x92,0xf6, 0x8f,0x64, 0x93,0x4f, 0x91,0xd4, 0x97,0xa0, 0x92,0x8d, 0x95,0x77, 0x8b,0x51, 0x8a,0xc5, 0x95,0xe0, 
0x91,0xac, 0x93,0x47, 0x94,0xec, 0x96,0xf2, 0x89,0xa4, 0x88,0xc4, 0x91,0xa2, 0x96,0x58, 0x8c,0xcd, 0x8d,0xde, 0x8c,0xbb, 0x92,0x4e, 0x96,0x59, 0x8e,0xe7, 0x90,0xb6, 0x8e,0xa6, 0x90,0x5f, 0x92,0x50, 0x88,0xd9, 0x92,0xed, 0x8b,0x90, 0x8c,0x8a, 0x8b,0x7d, 0x97,0x5d, 0x8e,0x9a, 0x97,0x56, 0x9a,0xd0, 0x97,0x90, 0x8f,0xee, 0x8c,0x80, 0x94,0xde, 0x96,0x5a, 
0x8d,0x44, 0x98,0x48, 0x93,0x4b, 0x93,0xad, 0x90,0xd3, 0x8a,0xd4, 0x8a,0xc4, 0x8e,0x8b, 0x8c,0xc2, 0x92,0x93, 0x90,0xd5, 0x8c,0x65, 0x8b,0xca, 0x91,0xec, 0x91,0xd9, 0x89,0x53, 0x8c,0xdb, 0x88,0xb3, 0x94,0x97, 0x8e,0xdc, 0x8c,0xd5, 0x8f,0xab, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 0x81,0x41, 

};
/*
"々、「」。ｒ２－７３（＋４．ｚ６Ｍ～？Ｘ１９ＤＰ！）　、、、、、",
"ジホネクビョエタワヌパユミゲサイオトロォガボゾナダヨゼィノケカェ",
"マニムペウァューポン・キザゴヘギバリシプチブグレヤヒハヴモゥピメ",
"ラドルソヶセヅコスズデャフツアヲテベッＢＧ、、、、、、、、、、、",
"よてかるえすあちうまでゆぐぉぢりぬおらさへどくろやんみずぽわこと",
"づねっごぅぼいぇふぺのぜほぱればゃめぃながぎきせぶつをげにひしだ",
"ぞぁざたけょじべはむもそび供ⅢⅠ：･♪■↑Ⅳ↓…←Ⅱ→、、、、、",
"秩説祈臓一回土免只耐特戴叩別攻完借島戦到基会健康沈入素身丈撃床集",
"悔増品浅魚友準序殴切屋血魔仕試我発紙仇失宿痴報以体拾昔這着妖始店",
"跳的廃制待家言陽空事含良保技済建様与貯勢背所果当実鋭安炉毎局炭光",
"題白子落全団電下永軍親黙敷終目悪頼庫役逃味客傍違爆藤元記思徊棒刑",
"行乗飽真惜逆伝使勝汎稼国浸大絡仲徘平牢破廊兄銀凝塊固灰随強捕朽詳",
"持賭調複進優能返盾葉喋懐彷燃導唯弾騒闇選痛隊三因狙貴後塗書起扇意",
"策小妬食娘鍵繰死怪険歳呑限走日込楽恩修縮機襲暗昇存釣士緒腕作多天",
"雑労解崩前夫戻流具洞鬼焼階証阿来奴座関開似払釜培域結閉降疲転丁俺",
"受接製踏段笑道効闊考念砂裂酷次百応泉無腹印甘暴出弱性冠父病支検暖",
"太許手確糧悲砲怖農憑新械横旦震八壁散未奥区久自定療取割花鈴同鼻曲",
"炎呆覚傷第離給他勘万慎幸時料脈扉徨録協剣爺伊操長愚駄索過宜復便射",
"係住頭谷宝今冶器危獄不化損産押触困晴願諦再恐析憎爽義窟員成為骸付",
"運相沢然途置面物通猛比方世練若講姿知犬罠超話民語吹室用主達十風極",
"武黄威口力才凶系活純憶彫質延正補最盗赤眺述育蓮期少術山巣命想火美",
"板渡識加感形頂者護噴博打原臆研私聖池何石勇蓋惑獣声密罰人常判夜厳",
"度心可闘備芽苦察残管君星魅二骨晶遅装妻礼殺退溜除鉄刻鍛要救断止飲",
"立月男変本喰迷処夢難宮休半臭表状喪送卵計症旅悟園愛飛囲分謎地放双",
"種狂馴必及僕反遠斜級噂嫌配馬漂格合得婆助檻登蘇絆査贈暮歯外奇早封",
"惨揮沼台有舞範順防援張名冷咲指動北虫挑聞服了利滅辺究連腰消見任突",
"足択遣験在上隠害望問倒木迎側栄掛探液初水投負雄年追嫉詰英潜騙古和",
"令金呼竜決墓居浮静端黒杯怒先絶魂牙栽肉工慕奪息中法屈寂箱精壊呂称",
"対従姉妙幾業敗答末売村文理荒明昆顔去泥閃近抜快禁頑源寝医減邪停塞",
"坂祖教信音色潰派向兵欲脱番像続広即移眠交差引呪秘裕数読換部帰高銃",
"匹孵功場内拠野点茶代母貫染女診予争幽気熱画倉程重徹態裏注婦飢看歩",
"速敵肥薬王案造帽枯材現誰忘守生示神単異弟巨穴急余字遊墟乱情劇彼忙",
"好路適働責間監視個駐跡憩玉卓胎唄鼓圧迫灼虎将、、、、、、、、、、"
*/
#endif



int gAtlas16Color1;
int gAtlas16Color2;

int gAtlas256Color;

int gTextureLoaded = 0;

int gTextureWidth1024 = 1;
int gTextureHeight512 = 1;

int gTextureWidth512 = 1;
int gTextureHeight256 = 1;

void* gCurrentPalette;

char gConsoleInited = false;

void ErrorInitConsole()
{
	//if(!gConsoleInited)
	//	consoleInit( NULL, 0, BgType_Text4bpp, BgSize_T_256x256, 23, 2, false, true );
	gConsoleInited = 2;
}

static unsigned int nextPowerOf2(unsigned int n)  
{  
    unsigned power = 1; 
    for(;;)
	{
		if(n <= power) return power;
		power <<= 1;
	}
}  



/*---------------------------------------------------------------------------------

	Video API vaguely similar to OpenGL

  Copyright (C) 2005
			Michael Noland (joat)
			Jason Rogers (dovoto)
			Dave Murphy (WinterMute)

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any
  damages arising from the use of this software.

  Permission is granted to anyone to use this software for any
  purpose, including commercial applications, and to alter it and
  redistribute it freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you
     must not claim that you wrote the original software. If you use
     this software in a product, an acknowledgment in the product
     documentation would be appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and
     must not be misrepresented as being the original software.
  3. This notice may not be removed or altered from any source
     distribution.


---------------------------------------------------------------------------------*/

//The following functions are modified from libnds.
//https://github.com/devkitPro/libnds/blob/master/source/arm9/videoGL.c



uint16* vramGetBank(uint16 *addr) {
//---------------------------------------------------------------------------------

}

int AssignColorPalette(SURFACE* surf, uint16 width, const uint16* table)
{

	
}
	static int channel = 0;
// Copy data from surf_no to texture
BOOL CopyDataToTexture(int paletteType, int textureid, int surf_no,  int xoffset, int yoffset, RECT* rect)
{


	return TRUE;
}


void initSubSprites(void){
//-------------------------------------------------------
 

}


// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//Draw to screen
BOOL Flip_SystemTask()
{
	//Update inputs
	char* text1 = "Press again to disconnect";
	char* text2 = "Disconnected from netplay.";
	if(nifiIsLinked() && gDisconnectTimer > 0)
		PutText(&grcGame, WINDOW_WIDTH - 16 - GetTextSpacing(text1), 16, text1, RGB(255, 255, 255));
	else if (gDisconnectTimer >= 1)
	{
		PutText(&grcGame, WINDOW_WIDTH - 16 - GetTextSpacing(text2), 16, text2, RGB(255, 255, 255));
	}

	if(gDisconnectTimer) gDisconnectTimer--;

	if(gDebug.bFastForward)
	{

		if(gDebug.FastForwardTimer++ % 5 == 0)
		{

			//glFlush(0);
			
			VBlankIntrWait();
		}
		else if(gDebug.FastForwardTimer % 5 == 4)
		{

		}
	}
	else
	{


		//glFlush(0);


		VBlankIntrWait();

		if(gb50Fps)
		{
			static unsigned long timePrev;
			static unsigned long timeNow;

			while (TRUE)
			{
				// Framerate limiter
				//timeNow = timerTicks2msec(cpuGetTiming());

				if (timeNow >= timePrev + 20)
					break;

				if (timeNow + 10000 < timePrev)
				{
					timeNow = timePrev = 0; //Timer overflowed
					break;
				}
			
			//	swiIntrWait(1, IRQ_TIMER2); //sleep(1)
			}

			if (timeNow >= timePrev + 100)
				timePrev = timeNow;	// If the timer is freakishly out of sync, panic and reset it, instead of spamming frames for who-knows how long
			else
				timePrev += 20;

		}

		//glBegin2D();
	}
	


	#ifdef TWO_SCREENS

		if((gCounter & 1) == 0)
		{
			lcdMainOnTop();
			vramSetBankD(VRAM_D_LCD);
			vramSetBankC(VRAM_C_SUB_BG);
			REG_DISPCAPCNT = DCAP_BANK(3) | DCAP_ENABLE | DCAP_SIZE(3);
		}
		else
		{
			lcdMainOnBottom();
			vramSetBankC(VRAM_C_LCD);
			vramSetBankD(VRAM_D_SUB_SPRITE);
			REG_DISPCAPCNT = DCAP_BANK(2) | DCAP_ENABLE | DCAP_SIZE(3);
		}
#endif

	UpdateInput();
	
	return TRUE;
}

BOOL StartDirectDraw()
{
	

	return TRUE;
}

void EndDirectDraw()
{
	//TODO
}

void ReleaseSurface(SurfaceID s)
{
	if(surf[s].data)
	{
		free(surf[s].data);
		surf[s].data = NULL;
	}
	if(surf[s].palette)
	{
		free(surf[s].palette);
		surf[s].palette = NULL;
	}
}

BOOL MakeSurface_Generic(int bxsize, int bysize, SurfaceID surf_no)
{
	if (surf_no < SURFACE_ID_MAX)
	{

		surf[surf_no].w = bxsize;
		surf[surf_no].h = bysize;
		//surf[surf_no].data = (BUFFER_PIXEL*)malloc(bxsize * bysize * sizeof(BUFFER_PIXEL));
		//surf[surf_no].palette = (u16*)malloc(256*(sizeof(u16)));
		surf[surf_no].textureid = NULL;
		surf[surf_no].paletteAddress = NULL;
		ReleaseSurface(surf_no);
	}

	return TRUE;
}


bool npcSymInArmsSlot = false;

BOOL LoadPortableNetworkGraphics(FILE_e* fp, SurfaceID surf_no, bool create_surface)
{


	return TRUE;

}



BOOL LoadBitmap(const char *name, SurfaceID surf_no, bool create_surface)
{

	bool loaded = false;

	char path[MAX_PATH];

	FILE_e *fp = NULL;

	return true;
	for(;;)
	{

		sprintf(path, "%s.png", name);
		fp = fopen_embed(path, "rb");
		
		if (fp)
		{
			printf("Loading surface (as .png) from %s for surface id %d\n", name, surf_no);
			if(LoadPortableNetworkGraphics(fp, surf_no, create_surface))
				break;
		}

		sprintf(path, "%s.bmp", name);
		
		unsigned char *file_buffer = NULL;
		LoadFileToMemory(path, &file_buffer);
		if (file_buffer)
		{
			printf("Loading surface (as .bmp) from %s for surface id %d\n", path, surf_no);
			if(LoadPalettedBMP(file_buffer, surf_no, create_surface))
			{
				free(file_buffer);
				break;
			}

			free(file_buffer);

		}

		//You FAILED
		fclose_embed(fp);
		return FALSE;
	}
	if(fp)
		fclose_embed(fp);

	int yoffset = 0;
	int xoffset = 0;
	int paletteOffset = 0;
	int textureid = gAtlas16Color1;

	RECT datarect = {0, 0, surf[surf_no].w, surf[surf_no].h};

	VramSlot table[] =
	{
		{SURFACE_ID_LEVEL_SPRITESET_1, gAtlas16Color1, 0, 0},
		{SURFACE_ID_LEVEL_SPRITESET_2, gAtlas256Color, 640, 0},
		{SURFACE_ID_NPC_SYM, gAtlas16Color1, 704, 256},
		{SURFACE_ID_CASTS, gAtlas16Color1, 256, 256},
		{SURFACE_ID_CREDITS_IMAGE, gAtlas16Color2, 480, 0},
		{SURFACE_ID_LEVEL_TILESET, gAtlas16Color1, 0, 240},
		{SURFACE_ID_TITLE, gAtlas16Color1, 0, 0},
		{SURFACE_ID_LOADING, gAtlas16Color1, 0, 0},
		{SURFACE_ID_PIXEL, gAtlas16Color1, 0, 48},
		{SURFACE_ID_BULLET, gAtlas16Color1, 256, 240},
		{SURFACE_ID_ARMS, gAtlas16Color2, 0, 0},
		{SURFACE_ID_ITEM_IMAGE, gAtlas16Color2, 64, 128},
		{SURFACE_ID_ARMS_IMAGE, gAtlas16Color1, 512, 496},
		{SURFACE_ID_STAGE_ITEM, gAtlas16Color1, 256, 496},
		{SURFACE_ID_FADE, gAtlas16Color1, 0, 480},
		{SURFACE_ID_NPC_REGU, gAtlas256Color, 0, 0},
		{SURFACE_ID_FACE, gAtlas16Color2, 888, 168},
		{SURFACE_ID_LEVEL_BACKGROUND, gAtlas16Color1, 640, 0},
		{SURFACE_ID_CARET, gAtlas16Color2, 320,0},
		{SURFACE_ID_TEXT_BOX, gAtlas16Color2, 640, 64},
		{SURFACE_ID_FONT, gAtlas16Color2, 640, 216},
		{SURFACE_ID_MY_CHAR, gAtlas16Color2, 640, 0},
		{SURFACE_ID_MY_CHAR2, gAtlas16Color2, 640, 0},
	};
	bool found = false;
	for (size_t i = 0; i < sizeof(table)/sizeof(table[0]); i++)
	{
		if(surf_no == table[i].id)
		{
			xoffset = table[i].x;
			yoffset = table[i].y;
			textureid = table[i].atlas;
			found = true;
			break;
		}
	}
	if(!found)
	{
		ReleaseSurface(surf_no);
		return FALSE;
	}

	if(surf_no == SURFACE_ID_NPC_SYM && npcSymInArmsSlot)
	{
		textureid = gAtlas16Color2;
		xoffset = 0;
		yoffset = 0;
	}
	if(surf_no == SURFACE_ID_FACE)
		goto facejump;

#ifdef JAPANESE
	if(surf_no == SURFACE_ID_FONT)
		{datarect.right = 384; datarect.bottom = 39;}
#endif

	if(!CopyDataToTexture(surf[surf_no].paletteType, textureid, surf_no, xoffset, yoffset, &datarect))
	{

		ReleaseSurface(surf_no);
		return FALSE;
	}

facejump:
	surf[surf_no].xoffset = xoffset;
	surf[surf_no].yoffset = yoffset;

	surf[surf_no].paletteOffset = AssignColorPalette(&surf[surf_no], 256, surf[surf_no].palette);


	if(surf_no != SURFACE_ID_TEXT_BOX && surf_no != SURFACE_ID_FACE
#ifdef JAPANESE
	&& surf_no != SURFACE_ID_FONT
#endif
	)
	{
		ReleaseSurface(surf_no);
	}
	
	return TRUE;
}

BOOL LoadBitmap_File(const char *name, SurfaceID surf_no, bool create_surface)
{
	return TRUE;
	// these surfs need to be reloaded again even if they were already loaded... i keep forgetting about this
	if(surf_no == SURFACE_ID_PIXEL || surf_no == SURFACE_ID_TITLE || surf_no == SURFACE_ID_CARET 
		|| surf_no == SURFACE_ID_BULLET || surf_no == SURFACE_ID_ITEM_IMAGE || surf_no == SURFACE_ID_NPC_SYM
		|| surf_no == SURFACE_ID_ARMS || surf_no == SURFACE_ID_CREDITS_IMAGE || surf_no == SURFACE_ID_CASTS)
	{

	}
	else if(!strcmp(name, surf[surf_no].name)) return TRUE; //don't reload surf if it's the same
	printf("LoadBitmap_File %s\n", name);
	printf("Memory: %d %d %d\n", mallinfo().arena, mallinfo().uordblks, mallinfo().fordblks);
	//Attempt to load file
	
	char path[MAX_PATH];
	sprintf(path, "%s/%s", gDataPath, name);
	
	if (LoadBitmap(path, surf_no, create_surface))
	{
		strcpy(surf[surf_no].name, name);
		return TRUE;
	}
			
	
	ErrorInitConsole();
	printf("Failed to open file %s\n", name);
	printf("Error: %d (%s)\n", errno, strerror(errno));
	return FALSE;
}

BOOL LoadBitmap_Resource(const char *res, SurfaceID surf_no, bool create_surface)
{
	//TODO
	return TRUE;
}

BOOL MakeSurface_File(const char *name, SurfaceID surf_no)
{
	return LoadBitmap_File(name, surf_no, true);
}

BOOL MakeSurface_Resource(const char *res, SurfaceID surf_no)
{
	return LoadBitmap_Resource(res, surf_no, true);
}

BOOL ReloadBitmap_File(const char *name, SurfaceID surf_no)
{
	return LoadBitmap_File(name, surf_no, false);
}

BOOL ReloadBitmap_Resource(const char *res, SurfaceID surf_no)
{
	return LoadBitmap_Resource(res, surf_no, false);
}

void BackupSurface(SurfaceID surf_no, RECT *rect)
{
	return;
	//TODO:
	for (int fx = rect->left; fx < rect->right; fx++)
	{
		for (int fy = rect->top; fy < rect->bottom; fy++)
		{
			int dx = fx - rect->left;
			int dy = fy - rect->top;
			
			if (dx < 0 || dy < 0)
				continue;
			if (dx >= surf[surf_no].w || dy >= surf[surf_no].h)
				continue;
			
			//BUFFER_PIXEL *fromPixel = &screenBuffer[fy * WINDOW_WIDTH + fx];
			//SET_BUFFER_PIXEL(surf[surf_no].data, surf[surf_no].w, dx, dy, fromPixel->r, fromPixel->g, fromPixel->b);
		}
	}
}

int gFaceNo = -1;
int gFaceNoCurrent = -1;

bool TextLinesDirty[6] = {0};

void CopyFaceTexture()
{
	if(gInMinimap) return;
	if(gFaceNoCurrent == gFaceNo) return;
	gFaceNoCurrent = gFaceNo;
	int face = gFaceNoCurrent;
	RECT rcFace;
	rcFace.left = (face % 6) * 48;
	rcFace.top = (face / 6) * 48;
	rcFace.right = rcFace.left + 48;
	rcFace.bottom = rcFace.top + 48;
	CopyDataToTexture(surf[SURFACE_ID_FACE].paletteType, gAtlas16Color2, SURFACE_ID_FACE, 
		surf[SURFACE_ID_FACE].xoffset, surf[SURFACE_ID_FACE].yoffset, &rcFace);
}

void CopyDirtyText()
{
	if(gInMinimap) return;
	for(int i=0;i<6;i++)
	{
		if(!TextLinesDirty[i]) continue;
		TextLinesDirty[i] = false;
		if(i == 4)
		{
			RECT rect = {0, 0, surf[SURFACE_ID_ROOM_NAME].w, surf[SURFACE_ID_ROOM_NAME].h};
			CopyDataToTexture(surf[SURFACE_ID_ROOM_NAME].paletteType, surf[SURFACE_ID_ROOM_NAME].textureid, SURFACE_ID_ROOM_NAME, 
			surf[SURFACE_ID_ROOM_NAME].xoffset, surf[SURFACE_ID_ROOM_NAME].yoffset, &rect);

		}
		else if (i == 5)
		{
			RECT rect = {0, 0, surf[SURFACE_ID_CREDIT_CAST].w, surf[SURFACE_ID_CREDIT_CAST].h};
			CopyDataToTexture(surf[SURFACE_ID_CREDIT_CAST].paletteType, surf[SURFACE_ID_CREDIT_CAST].textureid, SURFACE_ID_CREDIT_CAST, 
			surf[SURFACE_ID_CREDIT_CAST].xoffset, surf[SURFACE_ID_CREDIT_CAST].yoffset, &rect);
		}
		else
		{
			if(g_GameFlags & 8) return; //don't ruin credit cast in credits
			RECT rect = {0, 0, surf[SURFACE_ID_TEXT_LINE1].w, surf[SURFACE_ID_TEXT_LINE1].h};
			CopyDataToTexture(surf[30 + i].paletteType, surf[30 + i].textureid, 30 + i, 
			surf[30 + i].xoffset, surf[30 + i].yoffset, &rect);
		}
		
	}

}


void DrawBitmapSizeParam(RECT *rcView, int x, int y, int width, int height, RECT *rect, SurfaceID surf_no, bool transparent)
{

}
/*
__attribute__((hot))
void PutBitmap3(RECT *rcView, int x, int y, RECT *rect, SurfaceID surf_no) //Transparency
{
	DrawBitmap(rcView, x, y, rect, surf_no, true);
}

void PutBitmap4(RECT *rcView, int x, int y, RECT *rect, SurfaceID surf_no) //No Transparency
{
	DrawBitmap(rcView, x, y, rect, surf_no, false);
}*/

void PutBitmap3Transparent(RECT *rcView, int x, int y, RECT *rect, SurfaceID surf_no, u32 alpha)
{

}

int GetSurfPixel(int x, int y, int surf_no)
{
		//color = (bitmap_pixels[pos*2] | bitmap_pixels[pos*2+1] << 4);
	int height = (y * surf[surf_no].w) / 2;
	
	if(x % 2 == 0)
		return surf[surf_no].data[x/2 + height].color & 0x0F;
	else
		return surf[surf_no].data[x/2 + height].color >> 4;
}

#ifdef JAPANESE
static void SetFontChar(int dx, int dy, int sx, int sy, int surf_no)
{
	int startx = sx * 12;
	int starty = sy * 13;

	bool odd = false;
	if(dx % 2 == 1) odd = true;

	for(int k=0;k<13;k++)
	{
		if(!odd)
		{
			int height = ((starty + k) * surf[SURFACE_ID_FONT].w) / 2;
			int height2 = ((dy + k) * surf[surf_no].w) / 2;
			memcpy(&surf[surf_no].data[dx/2 + height2], 
				&surf[SURFACE_ID_FONT].data[(startx/2 + height)],
				12/2);	
		}
		else
		{
			for(int j=0;j<6;j++)
			{
				if(j==0)
				{
					int level0Color = GetSurfPixel(startx+(j*2), starty+k, SURFACE_ID_FONT);
					SetSurf2Pixels(dx + j*2, k + dy, surf_no, (level0Color << 4));
				}
				else
				{
					int level0Color = GetSurfPixel(startx+(j*2-1), starty+k, SURFACE_ID_FONT);
					int level1Color = GetSurfPixel(startx+(j*2), starty+k, SURFACE_ID_FONT);
					SetSurf2Pixels(dx + j*2, k + dy, surf_no, (level0Color | level1Color << 4));
				}
			}
		}
	}
}

static void SetFontSymbol(int dx, int dy, int surf_no)
{
	RECT rcSymbol = {64, 48, 72, 56};	
	int startx = 64;
	int starty = 48;

	for(int k=0;k<56-48;k++)
	{	
		int height = ((starty + k) * surf[SURFACE_ID_TEXT_BOX].w) / 2;
		int height2 = ((dy + k) * surf[surf_no].w) / 2;
		memcpy(&surf[surf_no].data[dx/2 + height2], 
			&surf[SURFACE_ID_TEXT_BOX].data[(startx/2 + height)],
			(72-64)/2);	
	}
}


#endif


void SetSurf2Pixels(int x, int y, int surf_no, char color)
{
	int height = (y * surf[surf_no].w) / 2;
	surf[surf_no].data[x/2 + height].color = color;
}

void Surface2Surface(int x, int y, RECT *rect, int to, int from)
{
	BUFFER_PIXEL* dFrom = surf[from].data;
	BUFFER_PIXEL* dTo = surf[to].data;


	int fW = surf[from].w;
	int fH = surf[from].h;

	int tW = surf[to].w;
	int tH = surf[to].h;

	int rectW = rect->right - rect->left;
	int rectH = rect->bottom - rect->top;

	int surfStartH = rect->top; 
	for(int h = 0; h < rectH; h++)
	{

		memcpy(dTo + (tW*h/2) + (tW*y/2) + (x/2),
				dFrom+((rect->left/2) + (fW*surfStartH/2)),
				(rectW/2));
		surfStartH++;
	}
}

void Surface2Texture(int x, int y, RECT *rect, int to, int from)
{
	//TODO
	CopyDataToTexture(surf[from].paletteType, surf[from].textureid, from, x + surf[to].xoffset, y + surf[to].yoffset, rect);
}

unsigned long GetCortBoxColor(unsigned long col)
{
	// TODO
	return col;
}

void CortBox(RECT *rect, uint32_t col)
{
	const unsigned char col_red = col & 0x0000FF;
	const unsigned char col_green = (col & 0x00FF00) >> 8;
	const unsigned char col_blue = (col & 0xFF0000) >> 16;
	//const BUFFER_PIXEL colPixel = {col_red, col_green, col_blue};

	//col = RGB15(col_red / 8, col_green / 8, col_blue / 8);
	
	//glBoxFilled(rect->left, rect->top, rect->right, rect->bottom, col);

}

void CortBoxAlpha(RECT *rect, uint32_t col, u32 alpha)
{
	const unsigned char col_red = col & 0x0000FF;
	const unsigned char col_green = (col & 0x00FF00) >> 8;
	const unsigned char col_blue = (col & 0xFF0000) >> 16;
	//const BUFFER_PIXEL colPixel = {col_red, col_green, col_blue};

	//col = RGB15(col_red / 8, col_green / 8, col_blue / 8);
	
	//glBoxFilledTransparent(rect->left, rect->top, rect->right, rect->bottom, col, alpha);

}


void CortBox2(RECT *rect, uint32_t col, SurfaceID surf_no)
{
	if (surf[surf_no].data)
	{
		int width = (rect->right - rect->left)/2;
		int height = rect->bottom - rect->top;
		int sW = surf[surf_no].w/2;
		for(int i=0;i<height;i++)
		{
			memset(&surf[surf_no].data[rect->left/2 + (((rect->top + i) * sW))], col, width * sizeof(BUFFER_PIXEL));
		}
		
		if(surf_no == SURFACE_ID_TEXT_LINE1) TextLinesDirty[0] = true;
		if(surf_no == SURFACE_ID_TEXT_LINE2) TextLinesDirty[1] = true;
		if(surf_no == SURFACE_ID_TEXT_LINE3) TextLinesDirty[2] = true;
		if(surf_no == SURFACE_ID_TEXT_LINE4) TextLinesDirty[3] = true;	
		if(surf_no == SURFACE_ID_ROOM_NAME) TextLinesDirty[4] = true;		
		if(surf_no == SURFACE_ID_CREDIT_CAST) TextLinesDirty[5] = true;
	}
}

void InitTextObject()
{
	MakeSurface_File("smalfont", SURFACE_ID_FONT);
}

static RECT GetFontRect(char character)
{
	RECT rect;
	bool found = false;
	int j,k;
	for(j=0;j<3;j++)
	{
		for(k=0;k<33;k++)
		{
			if(font_letters[j][k] == character)
			{	
				found = true;
				break;
			}
		}
		if(found) break;
	}
	rect = {k*6, j*12, k*6+6, j*12+12};
	return rect;
}

int GetTextSpacing(const char *text)
{
#ifndef JAPANESE
	int spacing = 0;
	char v;
	while (v = *text++)
	{
	    if ((v -= 0x20) >= 0x00 && v <= 0x60)
	    {
	        spacing += font_space[v];
	    }
	}
	return spacing;
#else

	int spacing = 0;
	int i = 0;
	while(text[i] != NULL)
	{
		if(text[i] & 0x80)
		{
			//hardcode this fucking character   ･
			if(text[i] == 0xa5)
			{
				spacing += font_space[17 + (6+3*32)];
				i++; continue;
			}
			bool found = false;
			for(int yy=0; yy<33;yy++)
			{
				for(int xx=0; xx<32; xx++)
				{
					if(text[i] == font_letters_shift_jis[xx*2 + (yy*32*2)] && text[i+1] == font_letters_shift_jis[xx*2 + (yy*32*2)+1])
					{
						spacing += font_space[xx +((yy+3)*32)];
						found = true;
						break;
					}
					
				}
				if(found) break;
			}
			i+=2;
		}
		else
		{
			char v = text[i];
	    	if ((v -= 0x20) >= 0x00 && v <= 0x60)
	    	{
	    	    spacing += font_space[v];
	    	}
			i++;
		}
	}
	return spacing;
#endif
}

void PutText(RECT* rcView, int x, int y, const char *text, unsigned long colour)
{
	iprintf("\x1b[%hu;%huH%s\n", y/10, x/10, text);
	return;
    char v;

	const unsigned char col_red = colour & 0x0000FF;
	const unsigned char col_green = (colour & 0x00FF00) >> 8;
	const unsigned char col_blue = (colour & 0xFF0000) >> 16;
	//colour = RGB15(col_red / 8, col_green / 8, col_blue / 8);
	

	//glColor(colour);
    while (v = *text++)
    {
        if ((v -= 0x20) >= 0x00 && v <= 0x60)
        {
			if(v == '=' - 0x20)
			{
				RECT rcSymbol = {64, 48, 72, 56};
#ifndef JAPANESE
				PutBitmap3(rcView, x, y + 2, &rcSymbol, SURFACE_ID_TEXT_BOX);
#endif
				x += font_space[v];
			}
			else
			{
#ifndef JAPANESE				
				RECT rect = {(v & 0x1F) << 3, (v / 32) * 12, ((v & 0x1F) + 1) << 3, ((v / 32) + 1) * 12};
#else
				RECT rect = {(v & 0x1F) * 12, (v / 32) * 13, ((v & 0x1F) + 1) *12, ((v / 32) + 1) * 13};
#endif
            	PutBitmap3(rcView, x, y, &rect, SURFACE_ID_FONT);
            	x += font_space[v];
			}

        }
    }
	//glColor( 0x7FFF );
}

void PutText2(int x, int y, const char *text, unsigned long color, SurfaceID surf_no)
{
#ifdef JAPANESE
	int i = 0;

	int dx = 0;
	
	//32 * 33
	RECT rect = {0,0,216,16};
	while(text[i] != NULL)
	{
		if(text[i] & 0x80)
		{
			//hardcode this fucking character   ･
			if(text[i] == 0xa5)
			{
				SetFontChar(x, y, 17, 6+3, surf_no);
				x += font_space[17 + (6+3*32)];
				i++; continue;
			}
			bool found = false;
			for(int yy=0; yy<33;yy++)
			{
				for(int xx=0; xx<32; xx++)
				{
					if(text[i] == font_letters_shift_jis[xx*2 + (yy*32*2)] && text[i+1] == font_letters_shift_jis[xx*2 + (yy*32*2)+1])
					{
						//printf("%x%x\n", font_letters_shift_jis[xx*2 + (yy*32*2)], font_letters_shift_jis[xx*2 + (yy*32*2)+1]);
						SetFontChar(x, y, xx, yy+3, surf_no);
						x += font_space[xx +((yy+3)*32)];
						found = true;
						break;
					}
					
				}
				if(found) break;
			}
			if(!found) 
			{
				//ErrorInitConsole(); printf("%x%x wtf\n", text[i], text[i+1]);
			}
			i+=2;
		}
		else
		{
			char v = text[i];
			if ((v -= 0x20) >= 0x00 && v <= 0x60)
        	{
				if(v == '=' - 0x20)
				{
					//RECT rcSymbol = {64, 48, 72, 56};
					SetFontSymbol(x-1, y+2, surf_no);
				}
				else
				{
        	    	SetFontChar(x, y, (v)%32, (v)/32, surf_no);
				}
		    	x += font_space[v];

        	}
			i++;
		}
	}
	if(surf_no == SURFACE_ID_ROOM_NAME)
	{
		TextLinesDirty[4] = true;
	}
	else if (surf_no == SURFACE_ID_CREDIT_CAST)
	{
		TextLinesDirty[5] = true;
	}
	else
	{
		TextLinesDirty[surf_no - 30] = true;
	}
	
	

#endif
}


void EndTextObject()
{
	ReleaseSurface(SURFACE_ID_FONT);
}
